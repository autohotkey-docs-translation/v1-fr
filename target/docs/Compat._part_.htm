<!DOCTYPE HTML>
<html lang="fr">
<head>
<title>Compatibilité des scripts | AutoHotkey</title>
<meta name="description" content="Découvrez ce qui a changé par rapport à AutoHotkey 1.0 et quel en est l'impact." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Compatibilité des scripts</h1>

<p>Bien que de nombreux scripts écrits pour AutoHotkey 1.0 ne nécessitent pas de modifications pour s'exécuter sur AutoHotkey 1.1, certains peuvent fonctionner de manière incorrecte en raison des différences nécessaires entre les deux versions. Comme les différences les plus problématiques n'affectent que les fonctionnalités avancées comme DllCall (), la plupart des utilisateurs n'ont pas besoin de s'inquiéter.</p>
<p>AutoHotkey 1.1 est également connu sous le nom de "AutoHotkey_L", tandis qu'AutoHotkey 1.0 a été rétrospectivement étiqueté "AutoHotkey Basic". Certaines anciennes versions d'AutoHotkey_L utilisaient les numéros de version 1.0. *, Donc pour plus de clarté, ce document fait référence aux deux branches d'AutoHotkey par nom plutôt que par numéro de version.</p>
<p class="note"><strong>Remarque:</strong> Certains des problèmes les plus courants sont causés par les modifications requises pour prendre en charge le texte Unicode et peuvent être évités en utilisant simplement la version ANSI d'AutoHotkey_L.</p>

<h2 id="toc">Table des matières</h2>
<h3>Basic</h3>
<p>Impact élevé</p>
<ul>
  <li><a href="#Syntax_Errors">Certaines erreurs de syntaxe ne sont plus tolérées</a></li>
  <li><a href="#FileRead">FileRead peut renvoyer des données binaires corrompues</a></li>
  <li><a href="#Names">Les noms de variables et de fonctions n'autorisent pas [, ] ou ?</a></li>
  <li><a href="#DPIScale">La mise à l'échelle DPI est activée par défaut pour les interfaces graphiques</a></li>
</ul>
<p>Impact moyen:</p>
<ul>
  <li><a href="#Transform">La sous-commande <em>Unicode</em> de Transform n'est pas disponible sur les versions Unicode</a></li>
  <li><a href="#Default_Script">AutoHotkey.ahk est lancé à la place d'AutoHotkey.ini</a></li>
  <li><a href="#SetFormat">SetFormat, Integer, <strong>H</strong> est sensible à la casse</a></li>
  <li><a href="#LastError">A_LastError est modifié par plus de commandes</a></li>
  <li><a href="#MsgBox">MsgBox gère les virgules de manière plus cohérente</a></li>
  <li><a href="#GuiOwner">Gui + Owner remplace les styles supplémentaires</a></li>
  <li><a href="#VistaSound">SoundSet et SoundGet fonctionnent mieux sur Vista et versions ultérieures</a></li>
  <li><a href="#Tilde">~ Tilde affecte le fonctionnement des touches de modification personnalisées</a></li>
  <li><a href="#ComboUpDown"><code>x &amp; y ::</code> provoque le déclenchement de <code>x ::</code> et de <code>x up ::</code> lorsque x est relâché</a></li>
</ul>
<p>impact faible:</p>
<ul>
  <li><a href="#IfIs">Si <em>var</em> est <em>type</em> ignore les paramètres régionaux du système par défaut</a></li>
  <li><a href="#Window_Groups">GroupActivate définit ErrorLevel et <em>Label</em> de GroupAdd fonctionne différemment</a></li>
  <li><a href="#Run">Run et RunWait interprètent <em>Target</em> différemment</a></li>
  <li><a href="#ControlZ">Control-Z n'est pas interprété comme une fin-de-fichier</a></li>
  <li><a href="#Compatibility_Mode">Le mode de compatibilité peut prêter à confusion</a></li>
  <li><a href="#IsCompiled">A_IsCompiled est toujours en lecture seule</a></li>
  <li><a href="#Escaped_Whitespace">Les séquences de début et de fin `t ne sont plus ignorées</a></li>
</ul>

<h3>Avancée</h3>
<ul>
  <li><a href="#Format">Unicode vs ANSI</a>
    <ul>
      <li><a href="#VarSetCapacity">VarSetCapacity</a></li>
      <li><a href="#DllCall">DllCall</a></li>
      <li><a href="#NumPutGet">NumPut / NumGet</a></li>
    </ul>
  </li>
  <li><a href="#ptr">Taille du pointeur</a></li>
</ul>

<h2 id="Basic">Basic</h2>

<span id="Validation"></span><h3 id="Syntax_Errors">Erreurs de syntaxe</h3>
<p>Certaines erreurs de syntaxe qui ont été tolérées par AutoHotkey Basic ne sont pas tolérées par AutoHotkey_L. La plupart de ces erreurs peuvent être facilement corrigées une fois identifiées. Les erreurs suivantes sont détectées immédiatement lors du lancement d'un script dans AutoHotkey_L et doivent être corrigées pour que le script s'exécute:</p>
<ul>
  <li>Un espace, une tabulation ou une virgule est requis entre chaque commande et ses paramètres. Par exemple, <code>MsgBox &lt;foo</code> et <code>If!foo</code> ne sont pas tolérés.</li>
  <li><code>Hotkey, If<i>Quelque chose</i></code>, où <i>Quelque chose</i> n'est pas valide, n'est pas toléré.</li>
</ul>
<p>Certaines autres erreurs de syntaxe sont détectées pendant l'exécution du script. Celles-ci provoquent l'affichage d'un message d'erreur avant de quitter le thread actuel:</p>
<ul>
  <li><strong>Commun:</strong> Options <a href="commands/Gui.htm#Options">Gui</a>, <a href="commands/Gui.htm#Show">Gui Show</a> ou <a href="commands/GuiControl.htm">GuiControl</a> non reconnues ou mal formatées.</li>
  <li>GroupAdd avec un nom de groupe vide. Auparavant, cela provoquait la fermeture <em>silencieuse</em> du thread.</li>
  <li>L'option de l'interface graphique <a href="commands/Gui.htm#LastFoundExist">+LastFoundExist</a> ne doit pas être combinée avec une autre option, car cela la ferait agir de la même manière que <a href="commands/Gui.htm#LastFound">+LastFound</a>.</li>
</ul>
<p>Certaines autres erreurs de syntaxe ne sont actuellement pas détectées, mais provoquent des problèmes avec AutoHotkey_L:</p>
<ul>
  <li><a href="Variables.htm#concat">Auto-concat</a> avec <code>(</code> est plus sélectif, donc certaines expressions invalides comme <code>12(34)</code> ne fonctionnent plus.</li>
</ul>

<h3 id="FileRead">FileRead</h3>
<p><a href="commands/FileRead.htm#Binary">FileRead</a> traduit du texte entre les pages de code dans certains cas courants et peut donc générer des données binaires corrompues. Pour éviter cela, ajoutez l'option <code>*c</code> ou utilisez plutôt <a href="commands/FileOpen.htm">FileOpen()</a>.</p>

<h3 id="Names">Noms des variables et des fonctions</h3>
<p>Les caractères <code>[</code>, <code>]</code> et <code>?</code> sont réservés pour une utilisation dans les <a href="Variables.htm#Expressions">expressions</a>, ils ne sont donc plus valides dans les noms de variables. Par conséquent, <code>?</code> (utilisé dans les <a href="Variables.htm#ternary">opérations ternaires</a>) ne nécessite plus d'espace de chaque côté. Voir aussi <a href="Objects.htm#Syntax">syntaxe d'objet</a>.</p>
<p>Les erreurs peuvent ou non être détectées automatiquement:</p>
<ul>
  <li>Si un script a utilisé ces caractères dans des noms de variables dans des expressions, le script s'exécutera généralement sans afficher de message d'erreur, mais se comportera mal car les caractères seront interprétés comme des opérateurs plutôt que comme faisant partie d'un nom de variable.</li>
  <li>If these characters are used in a <a href="Variables.htm#ref">double-deref</a> (such as <code>Array%n%</code> where <em>n</em> contains one of the above characters), an error message is displayed when the double-deref is evaluated, while the script is running.</li>
  <li>If these characters are used in other contexts, such as on the left hand side of an assignment, in the name of a command's input/output variable or between %percent% signs, an error message is displayed and the script is prevented from launching.</li>
</ul>

<h3 id="DPIScale">DPI Scaling</h3>
<p><a href="commands/Gui.htm#DPIScale">DPI scaling</a> is enabled by default for script GUIs to ensure they scale according to the <a href="Variables.htm#ScreenDPI">system DPI setting</a>.  If enabled and the system DPI setting is not 96 (100%), positions and sizes accepted by or returned from Gui commands are not compatible with other commands.  To disable DPI scaling, use <code>Gui -DPIScale</code>.</p>

<h3 id="Transform">Transform</h3>
<p>Some <i>Transform</i> sub-commands are altered or unavailable in Unicode versions of AutoHotkey_L:</p>
<ul>
  <li><a href="commands/Transform.htm#Unicode">Transform, Unicode</a> is unavailable. To assign Unicode text to the clipboard, use a regular assignment. See also: <a href="commands/StrPut.htm">StrPut()</a> / <a href="commands/StrGet.htm">StrGet()</a>.</li>
  <li><a href="commands/Transform.htm#HTML">Transform, HTML</a> supports additional features.</li>
</ul>

<h3 id="Default_Script">Default Script</h3>
<p>When AutoHotkey_L is launched without specifying a script, an .ahk file is loaded by default instead of an .ini file.  The name of this file depends on the filename of the current executable.  For more details, see <a href="Scripts.htm#cmd">Passing Command Line Parameters to a Script</a>.</p>

<h3 id="SetFormat">SetFormat, Integer[Fast], H</h3>
<p>When an uppercase H is used, hexadecimal digits A-F will also be in uppercase.  AutoHotkey Basic always uses lowercase digits. See <a href="commands/SetFormat.htm">SetFormat</a>.</p>

<h3 id="LastError">A_LastError</h3>
<p>The following commands now set <a href="Variables.htm#LastError">A_LastError</a> to assist with debugging: FileAppend, FileRead, FileReadLine, FileDelete, FileCopy, FileMove, FileGetAttrib/Time/Size/Version, FileSetAttrib/Time, FileCreateDir, RegRead, RegWrite, RegDelete.  Using any of these commands causes the previous value of A_LastError to be overwritten.</p>

<h3 id="MsgBox">MsgBox</h3>
<p><a href="commands/MsgBox.htm">MsgBox</a>'s smart comma handling has been changed to improve flexibility and consistency with all other commands.  In most cases, MsgBox will just work as intended.  In some rare cases, scripts relying on the old quirky behaviour may observe a change in behaviour.  For instance:</p>
<pre><em>; This is now interpreted as an expression (Options) followed by text (Title)
; instead of as a single expression (Text) with multiple <a href="Variables.htm#comma">sub-expressions</a>:</em>
MsgBox % x, y
<em>; Parentheses can be added to force the old interpretation:</em>
MsgBox % (x, y)

<em>; This now shows an empty dialog instead of the text "0, Title":</em>
MsgBox 0, Title
<em>; These behave as expected in both AutoHotkey_L and AutoHotkey Basic:</em>
MsgBox 0, Title, % ""   <em>; Shows an empty dialog</em>
MsgBox 0`, Title        <em>; Shows the text "0, Title"</em>

<em>; This now shows an empty dialog instead of the text ", Title":</em>
MsgBox,, Title
</pre>

<h3 id="GuiOwner">Gui +Owner</h3>
<p>Applying the <a href="commands/Gui.htm#Owner">+Owner</a> option to a Gui also removes the WS_CHILD style and sets the WS_POPUP style. This may break scripts which used <code>+Owner</code> to set the parent window of a Gui <em>after</em> setting the styles.</p>

<h3 id="VistaSound">Sound Commands on Windows Vista and later</h3>
<p><a href="commands/SoundSet.htm">SoundSet</a>, <a href="commands/SoundGet.htm">SoundGet</a>, <a href="commands/SoundSetWaveVolume.htm">SoundSetWaveVolume</a> and <a href="commands/SoundGetWaveVolume.htm">SoundGetWaveVolume</a> have improved support for Windows Vista and later.  Typical changes in behaviour include:</p>
<ul>
  <li>Scripts affecting the whole system (as is usually intended) instead of just the script itself.</li>
  <li>Devices being numbered differently - each output or input is considered a separate device.</li>
</ul>

<h3 id="Tilde">~Tilde and Custom Combination Hotkeys</h3>
<p>As of <span class="ver">[v1.1.14]</span>, the <a href="Hotkeys.htm#Tilde">tilde prefix</a> affects how a key works when used as a modifier key in a custom combination.</p>

<h3 id="ComboUpDown">Custom Combinations and Down/Up Hotkeys</h3>
<p>Except when the tilde prefix is used, if both a key-down and a key-up hotkey are defined for a custom modifier key, they will both fire when the key is released.  For example, <code>x &amp; y::</code> causes both <code>x::</code> and <code>x up::</code> to fire when x is released, where previously <code>x::</code> never fired.</p>

<h3 id="IfIs">If <em>var</em> is <em>type</em></h3>
<p><a href="commands/IfIs.htm">If <em>var</em> is <em>type</em></a> ignores the system locale unless <a href="commands/StringCaseSense.htm">StringCaseSense, Locale</a> has been used.</p>

<h3 id="Window_Groups">Window Groups</h3>
<p><a href="commands/GroupActivate.htm">GroupActivate</a> sets ErrorLevel to 1 if no window was found to activate or 0 otherwise.  Previously, ErrorLevel was left unchanged.</p>
<p><a href="commands/GroupAdd.htm">GroupAdd</a>'s <em>Label</em> parameter applies to the window group as a whole instead of to one particular window specification within the group.  A discussion of this change can be found <a href="https://www.autohotkey.com/community/viewtopic.php?t=61362">on the forums</a>.  However, using this parameter is <strong>not recommended</strong>; check ErrorLevel after calling GroupActivate instead.</p>

<h3 id="Run">Run / RunWait</h3>
<p>AutoHotkey_L includes some enhancements to the way the <a href="commands/Run.htm">Run</a> and <a href="commands/Run.htm">RunWait</a> commands interpret the <em>Target</em> parameter.  This allows some things that didn't work previously, but in some very rare cases, may also affect scripts which were already working in AutoHotkey Basic.  The new behaviour is as follows:</p>
<ul>
  <li>If <i>Target</i> begins with a quotation mark, everything up to the next quotation mark is considered the action, typically an executable file.</li>
  <li>Otherwise the first substring which ends at a space and is either an existing file or ends in .exe, .bat, .com, .cmd or .hta is considered the action. This allows file types such as .ahk, .vbs or .lnk to accept parameters while still allowing "known" executables such as wordpad.exe to be launched without an absolute path as in previous versions.</li>
</ul>

<h3 id="ControlZ">Control-Z</h3>
<p><a href="commands/LoopReadFile.htm">Loop Read</a> and <a href="commands/FileReadLine.htm">FileReadLine</a> no longer interpret the character <kbd>Control</kbd>+<kbd>Z</kbd> (0x1A) as an end-of-file marker.  Any <kbd>Control</kbd>+<kbd>Z</kbd>, even one appearing at the very end of the file, is loaded as-is.  <a href="commands/FileRead.htm">FileRead</a> already ignored this character, so is not affected by this issue.</p>

<h3 id="Compatibility_Mode">Compatibility Mode</h3>
<p>If <a href="https://support.microsoft.com/en-us/help/15078/windows-make-older-programs-compatible">Compatibility mode</a> is set to Windows 95, 98/ME or NT4 in the properties of the EXE file used to run the script, the script may not behave correctly.  This is because compatibility mode causes a specific version of Windows to be reported to the application, but AutoHotkey_L omits support for these versions.  For example, setting compatibility mode to Windows 95 or 98/ME will cause <code>MsgBox %A_OSVersion%</code> to report <code>WIN_NT4</code>.</p>

<h3 id="IsCompiled">A_IsCompiled</h3>
<p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> is defined as an empty string if the script has not been compiled.  Previously it was left undefined, which meant that assignments such as <code>A_IsCompiled := 1</code> were valid if the script hadn't been compiled.  Now it is treated as a read-only built-in variable in all cases.</p>

<h3 id="Escaped_Whitespace">Escaped Whitespace</h3>
<p>Escaped whitespace characters such as <code>`t</code> and <code>` </code> are no longer trimmed from the beginning and end of each arg.  For example, <code>StringReplace s, s, `t</code> is now valid and will remove all tab characters from <em>s</em>.</p>


<h2 id="Format">Unicode vs ANSI</h2>
<p class="note"><strong>Note:</strong> This section builds on topics covered in other parts of the documentation: <a href="Concepts.htm#strings">Strings</a>, <a href="Concepts.htm#string-encoding">String Encoding</a>.</p>
<p>Within a string (text value), the numeric character code and size (in bytes) of each character depends on the <a href="Concepts.htm#native-encoding">native encoding</a> of the script or AutoHotkey executable; i.e. <i>Unicode</i> or <i>ANSI</i>.  These details are typically important for scripts which do any of the following:</p>
<ul>
  <li>Pass strings to external functions via <a href="#DllCall">DllCall</a>.</li>
  <li>Pass strings via <a href="commands/PostMessage.htm">PostMessage/SendMessage</a>.</li>
  <li>Manipulate strings directly via <a href="#NumPutGet">NumPut/NumGet</a>.</li>
  <li>Use <a href="#VarSetCapacity">VarSetCapacity</a> to ensure a variable can hold a specific number of characters.</li>
</ul>
<p>Scripts designed with one particular format in mind will often encounter problems when run on the wrong version of AutoHotkey.  For instance, some scripts written for AutoHotkey Basic will function correctly on the ANSI version of AutoHotkey_L but fail on Unicode versions.  If you aren't sure which version you are using, run the following script:</p>
<pre>MsgBox % <a href="Variables.htm#IsUnicode">A_IsUnicode</a> ? "Unicode" : "ANSI"</pre>
<p><strong>ANSI:</strong> Each character is <strong>one byte</strong> (8 bits).  Character codes above 127 depend on your system's language settings.</p>
<p><strong>Unicode:</strong> Each character is <strong>two bytes</strong> (16 bits).  Character codes are as defined by the <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> format.</p>
<p class="Indent"><em>Semantic note:</em> Technically, some Unicode characters are represented by <i>two</i> 16-bit code units, collectively known as a "surrogate pair."  Similarly, some <a href="http://msdn.microsoft.com/en-us/library/dd317752.aspx">ANSI code pages</a> (commonly known as <a href="http://msdn.microsoft.com/en-us/library/dd317794.aspx">Double Byte Character Sets</a>) contain some double-byte characters.  However, for practical reasons these are almost always treated as two individual units (referred to as "characters" for simplicity).</p>

<h3 id="VarSetCapacity">VarSetCapacity</h3>
<p>VarSetCapacity sets the capacity of a var <i>in bytes</i>.  To set a variable's capacity based on the number of characters, the size of a character must be taken into account.  For example:</p>
<pre>VarSetCapacity(ansi_var,    capacity_in_chars)
VarSetCapacity(unicode_var, capacity_in_chars * 2)
VarSetCapacity(native_var,  capacity_in_chars * (A_IsUnicode ? 2 : 1))
VarSetCapacity(native_var,  t_size(capacity_in_chars))  <em>; see <a href="#NumPutGet">below</a></em>
</pre>
<p>There are two main uses for VarSetCapacity:</p>
<ol>
  <li>Expand a variable to hold an estimated number of characters, to enhance performance when building a string by means of gradual concatenation.  For example, <code>VarSetCapacity(var, 1000)</code> allows for 1000 bytes, which is only 500 characters on Unicode versions of AutoHotkey_L.  This could affect performance, but the script should still function correctly.</li>
  <li>Resize a variable to hold a binary structure.  If the structure directly contains text, the format of that text must be taken into account.  This depends on the structure - sometimes ANSI text will be used even in a Unicode version of AutoHotkey_L.  If the variable is too small, the script may crash or otherwise behave unpredictably (depending on how the structure is used).</li>
</ol>

<h3 id="DllCall">DllCall</h3>
<p>When the "Str" type is used, it means a string in the native format of the current build.  Since some functions may require or return strings in a particular format, the following string types are available:</p>
<table class="info">
  <tr><th>&nbsp;</th><th>Char Size</th><th>C / Win32 Types</th><th>Encoding</th></tr>
  <tr><td class="Syntax" style="text-align:center">WStr</td><td style="text-align:center">16-bit</td><td>wchar_t*, WCHAR*, LPWSTR, LPCWSTR</td><td>UTF-16</td></tr>
  <tr><td class="Syntax" style="text-align:center">AStr</td><td style="text-align:center">8-bit</td><td>char*, CHAR*, LPSTR, LPCSTR</td><td>ANSI (the system default ANSI code page)</td></tr>
  <tr><td class="Syntax" style="text-align:center">Str</td><td style="text-align:center">--</td><td>TCHAR*, LPTSTR, LPCTSTR</td><td>Equivalent to <b>WStr</b> in Unicode builds and <b>AStr</b> in ANSI builds.</td></tr>
</table>
<p>If "Str" or the equivalent type for the current build is used as a parameter, the address of the string or var is passed to the function, otherwise a temporary copy of the string is created in the desired format and passed instead. As a general rule, "AStr" and "WStr" should not be used if the function writes a value into that parameter.</p>
<p class="note"><b>Note:</b> "AStr" and "WStr" are equally valid for parameters and the function's return value.</p>
<p>In general, if a script calls a function via DllCall() which accepts a string as a parameter, one of the following approaches must be taken:</p>
<ol>
  <li>If both Unicode (W) and ANSI (A) versions of the function are available, call the appropriate one for the current build.  In the following example, "DeleteFile" is internally known as "DeleteFileA" or "DeleteFileW".  Since "DeleteFile" itself doesn't really exist, DllCall() automatically tries "A" or "W" as appropriate for the current build:
  
  <pre>DllCall("DeleteFile", "Ptr", &amp;filename)
DllCall("DeleteFile", "Str", filename)</pre>
  <p>In this example, <code>&amp;filename</code> passes the address of the string exactly as-is, so the function must expect a string in the same format as the "Str" type. Note that "UInt" must be used in place of "Ptr" in AutoHotkey Basic, but the resulting code may not be 64-bit compatible.</p>
  <p class="note"><b>Note:</b> If the function cannot be found exactly as specified, AutoHotkey_L appends the "A" or "W" suffix regardless of which DLL is specified.  However, AutoHotkey Basic appends the "A" suffix only for functions in User32.dll, Kernel32.dll, ComCtl32.dll, or Gdi32.dll.</p></li>
  <li>If the function only accepts a specific type of string as input, the script may use the appropriate string type:
  
  <pre>DllCall("DeleteFileA", "AStr", filename)
DllCall("DeleteFileW", "WStr", filename)</pre></li>
  <li>If the function must modify a string (in a non-native format), the script must allocate a buffer as described <a href="#VarSetCapacity">above</a> and pass its address to the function.  If the parameter accepts input, the script must also convert the input string to the appropriate format; this can be done using <a href="commands/StrPut.htm">StrPut()</a>.</li>
</ol>

<h3 id="NumPutGet">NumPut / NumGet</h3>
<p>When NumPut() or NumGet() are used with strings, the offset and type must be correct for the given type of string.  The following may be used as a guide:</p>
<pre><em>;  8-bit/ANSI   strings:  size_of_char=1  type_of_char="Char"
; 16-bit/UTF-16 strings:  size_of_char=2  type_of_char="UShort"</em>
<i>n</i>th_char := NumGet(var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)
NumPut(<i>n</i>th_char, var, (<i>n</i>-1)*<i>size_of_char</i>, <i>type_of_char</i>)</pre>
<p>If <code>var</code> contains a string in the native format, the appropriate values may be determined based on the value of <code>A_IsUnicode</code>:</p>
<pre><i>n</i>th_char := NumGet(var, t_size(<i>n</i>-1), t_char())
NumPut(<i>n</i>th_char, var, t_size(<i>n</i>-1), t_char())

<em>; Define functions for convenience and clarity:</em>
t_char() {
    return A_IsUnicode ? "UShort" : "Char"
}
t_size(char_count=1) {
    return A_IsUnicode ? char_count*2 : char_count
}</pre>

<h2 id="ptr">Taille du pointeur</h2>
<p>Pointers are 4 bytes in 32-bit builds (including AutoHotkey Basic) and 8 bytes in 64-bit builds. Scripts using structures or DllCalls may need to account for this to run correctly on both platforms. Specific areas which are affected include:</p>
<ul>
  <li>Offset calculation for fields in structures which contain one or more pointers.</li>
  <li>Size calculation for structures containing one or more pointers.</li>
  <li>Type names used with <a href="commands/DllCall.htm">DllCall()</a>, <a href="commands/NumPut.htm">NumPut()</a> or <a href="commands/NumGet.htm">NumGet()</a>.</li>
</ul>
<p>For size and offset calculations, use <a href="Variables.htm#PtrSize">A_PtrSize</a>. For DllCall(), NumPut() and NumGet(), use the <a href="commands/DllCall.htm">Ptr</a> type where appropriate.</p>
<p>Remember that the offset of a field is usually the total size of all fields preceding it. Also note that handles (including types like HWND and HBITMAP) are essentially pointer-types.</p>
<pre><em>/*
  typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;    // Ptr
    HANDLE hThread;
    DWORD  dwProcessId; // UInt (4 bytes)
    DWORD  dwThreadId;
  } <a href="http://msdn.microsoft.com/en-us/library/ms684873.aspx">PROCESS_INFORMATION</a>, *LPPROCESS_INFORMATION;
*/</em>
VarSetCapacity(pi, A_PtrSize*2 + 8) <em>; Ptr + Ptr + UInt + UInt</em>
DllCall("<a href="http://msdn.microsoft.com/en-us/library/ms682425.aspx">CreateProcess</a>", <span class="dull">&lt;omitted for brevity&gt;</span>, "Ptr", &amp;pi, <span class="dull">&lt;omitted&gt;</span>)
hProcess    := NumGet(pi, 0)         <em>; Defaults to "Ptr".</em>
hThread     := NumGet(pi, A_PtrSize) <em>;</em>
dwProcessId := NumGet(pi, A_PtrSize*2,     "UInt")
dwProcessId := NumGet(pi, A_PtrSize*2 + 4, "UInt")
</pre>


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>
